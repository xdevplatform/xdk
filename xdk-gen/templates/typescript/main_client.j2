/**
 * Main client for the X API.
 *
 * This module provides the main client class for interacting with the X API.
 */

import { httpClient } from "./http-client.js";

{% for tag in tags %}
import { {{ tag | pascal_case }}Client } from "./{{ tag | snake_case }}/index.js";
{% endfor %}

/**
 * Configuration options for the X API client
 */
export interface ClientConfig {
  /** Base URL for API requests */
  baseUrl?: string;
  /** Bearer token for authentication */
  bearerToken?: string;
  /** OAuth2 access token */
  accessToken?: string;
  /** OAuth1 instance for authentication */
  oauth1?: any;
  /** Custom headers to include in requests */
  headers?: Record<string, string>;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Whether to automatically retry failed requests */
  retry?: boolean;
  /** Maximum number of retry attempts */
  maxRetries?: number;
  /** User agent string */
  userAgent?: string;
}

/**
 * API Error class for handling X API errors
 */
export class ApiError extends Error {
  public readonly status: number;
  public readonly statusText: string;
  public readonly headers: Headers;
  public readonly data?: any;

  constructor(message: string, status: number, statusText: string, headers: Headers, data?: any) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
    this.statusText = statusText;
    this.headers = headers;
    this.data = data;
  }
}

/**
 * Request options for API calls
 */
export interface RequestOptions {
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Additional headers */
  headers?: Record<string, string>;
  /** Request signal for cancellation */
  signal?: AbortSignal;
  /** Request body */
  body?: string;
}

/**
 * Response wrapper with metadata
 */
export interface ApiResponse<T = any> {
  /** Response data */
  data: T;
  /** Response headers */
  headers: Headers;
  /** HTTP status code */
  status: number;
  /** HTTP status text */
  statusText: string;
  /** Response URL */
  url: string;
}

/**
 * Pagination metadata
 */
export interface PaginationMeta {
  /** Next page token */
  next_token?: string;
  /** Previous page token */
  previous_token?: string;
  /** Total count */
  total_count?: number;
  /** Result count */
  result_count?: number;
}

/**
 * Paginated response wrapper
 */
export interface PaginatedResponse<T = any> extends ApiResponse<T[]> {
  /** Pagination metadata */
  meta: PaginationMeta;
}

/**
 * Main client class for the X API
 */
export class Client {
  /** Base URL for API requests */
  readonly baseUrl: string;
  /** Bearer token for authentication */
  readonly bearerToken?: string;
  /** OAuth2 access token */
  readonly accessToken?: string;
  /** OAuth1 instance for authentication */
  readonly oauth1?: any;
  /** Headers for requests */
  readonly headers: Headers;
  /** Request timeout in milliseconds */
  readonly timeout: number;
  /** Whether to automatically retry failed requests */
  readonly retry: boolean;
  /** Maximum number of retry attempts */
  readonly maxRetries: number;
  /** User agent string */
  readonly userAgent: string;

  /** HTTP client for making requests */
  readonly httpClient = httpClient;

{% for tag in tags %}
  /** {{ tag }} client */
  readonly {{ tag | snake_case }}: {{ tag | pascal_case }}Client;
{% endfor %}

  constructor(config: ClientConfig | any) {
    // Handle OAuth1 instance passed directly
    if (config && typeof config === 'object' && config.accessToken && config.accessToken.accessToken && config.accessToken.accessTokenSecret) {
      // This is an OAuth1 instance
      this.oauth1 = config;
      this.baseUrl = "https://api.x.com";
    } else {
      // This is a regular config object
      const clientConfig = config as ClientConfig;
      this.baseUrl = clientConfig.baseUrl || "https://api.x.com";
      this.bearerToken = clientConfig.bearerToken;
      this.accessToken = clientConfig.accessToken;
      this.oauth1 = clientConfig.oauth1;
    }
    
    this.timeout = (config as ClientConfig).timeout || 30000;
    this.retry = (config as ClientConfig).retry ?? true;
    this.maxRetries = (config as ClientConfig).maxRetries || 3;
    this.userAgent = (config as ClientConfig).userAgent || "x-api-sdk/1.0.0";
    
    // Initialize headers
    const defaultHeaders: Record<string, string> = {
      'User-Agent': this.userAgent,
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...((config as ClientConfig).headers || {}),
    };
    
    this.headers = httpClient.createHeaders(defaultHeaders);

{% for tag in tags %}
    this.{{ tag | snake_case }} = new {{ tag | pascal_case }}Client(this);
{% endfor %}
  }

  /**
   * Make an authenticated request to the API
   */
  async request<T = any>(
    method: string,
    path: string,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${path}`;
    const headers = new Headers(this.headers);
    
    // Add authentication headers
    if (this.bearerToken) {
      headers.set('Authorization', `Bearer ${this.bearerToken}`);
    } else if (this.accessToken) {
      headers.set('Authorization', `Bearer ${this.accessToken}`);
    } else if (this.oauth1 && this.oauth1.accessToken) {
      // OAuth1 authentication - build proper OAuth1 header
      try {
        const oauthHeader = await this.oauth1.buildRequestHeader(method, url, options.body || '');
        headers.set('Authorization', oauthHeader);
        
        // Remove Content-Type for OAuth1 requests if it's application/json
        // OAuth1 typically expects application/x-www-form-urlencoded or no content type
        if (headers.get('Content-Type') === 'application/json') {
          headers.delete('Content-Type');
        }
      } catch (error) {
        throw new Error(`Failed to build OAuth1 header: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }
    
    // Add custom headers
    if (options.headers) {
      Object.entries(options.headers).forEach(([key, value]) => {
        headers.set(key, value);
      });
    }

    try {
      const response = await this.httpClient.request(url, {
        method,
        headers,
        signal: options.signal,
        body: options.body,
      });

      if (!response.ok) {
        let errorData: any;
        try {
          errorData = await response.json();
        } catch {
          errorData = await response.text();
        }
        
        throw new ApiError(
          errorData && errorData.message ? errorData.message : `HTTP ${response.status}: ${response.statusText}`,
          response.status,
          response.statusText,
          response.headers,
          errorData
        );
      }

      let data: T;
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        data = await response.json();
      } else {
        data = await response.text() as T;
      }

      return {
        data,
        headers: response.headers,
        status: response.status,
        statusText: response.statusText,
        url: response.url || url,
      };
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(
        error instanceof Error ? error.message : 'Request failed',
        0,
        'NETWORK_ERROR',
        new Headers(),
        error
      );
    }
  }

  /**
   * Check if the OAuth2 token is expired
   */
  isTokenExpired(): boolean {
    // TODO: Implement token expiration check
    return false;
  }

  /**
   * Refresh the OAuth2 token
   */
  async refreshToken(): Promise<void> {
    // TODO: Implement token refresh
  }

  /**
   * Get the current authentication status
   */
  isAuthenticated(): boolean {
    return !!(this.bearerToken || this.accessToken || (this.oauth1 && this.oauth1.accessToken));
  }
} 