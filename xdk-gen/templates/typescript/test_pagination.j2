/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated pagination tests for {{ tag.class_name }} client.
 *
 * This module contains tests that validate pagination functionality
 * using the Paginator class for methods that support pagination. Tests verify
 * proper handling of pagination tokens, page limits, and item iteration.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { {{ tag.class_name }}Client } from '../../src/{{ tag.import_name }}/client.js';
import { Client } from '../../src/client.js';
import { Paginator } from '../../src/paginator.js';

describe('{{ tag.class_name }}Client Pagination', () => {
  let client: Client;
  let {{ tag.property_name }}Client: {{ tag.class_name }}Client;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    {{ tag.property_name }}Client = client.{{ tag.property_name }};
  });

  {% for pagination_test in test_spec.pagination_tests %}
  it('should create paginator for {{ pagination_test.method_name }}', () => {
    const method = ({{ tag.property_name }}Client as any)['{{ pagination_test.method_name }}'];
    
    // Should be able to create paginator without error
    const params: any = {
      {% for param in pagination_test.required_params %}
      {% if param.param_type == "string" %}
      {% if "query" in param.variable_name %}
      {{ param.name }}: 'test_query',
      {% elif "id" in param.variable_name %}
      {{ param.name }}: 'test_id',
      {% else %}
      {{ param.name }}: 'test_{{ param.name }}',
      {% endif %}
      {% elif param.param_type == "boolean" %}
      {{ param.name }}: true,
      {% elif param.param_type == "integer" %}
      {{ param.name }}: 1,
      {% else %}
      {{ param.name }}: 'test_value',
      {% endif %}
      {% endfor %}
      maxResults: 10
    };
    
    // Note: Paginator creation is typically done through the method itself
    // This test verifies the method supports pagination
    expect(typeof method).toBe('function');
  });

  it('should paginate through pages for {{ pagination_test.method_name }}', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to return paginated responses (like Python mocks session)
    let callCount = 0;
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockImplementation(() => {
      callCount++;
      if (callCount === 1) {
        // First page response
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            {{ pagination_test.data_field }}: [
              { id: '1', name: 'Item 1' },
              { id: '2', name: 'Item 2' }
            ],
            meta: {
              {% if pagination_test.next_token_field %}
              '{{ pagination_test.next_token_field|last_part }}': 'next_page_token',
              {% endif %}
              result_count: 2
            }
          }),
          text: async () => '{}'
        } as Response);
      } else {
        // Second page response (no next token = end of pagination)
        return Promise.resolve({
          ok: true,
          status: 200,
          statusText: 'OK',
          headers: new Headers({ 'content-type': 'application/json' }),
          json: async () => ({
            {{ pagination_test.data_field }}: [
              { id: '3', name: 'Item 3' }
            ],
            meta: {
              result_count: 1
            }
          }),
          text: async () => '{}'
        } as Response);
      }
    });

    try {
      const method = ({{ tag.property_name }}Client as any)['{{ pagination_test.method_name }}'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      {% for param in pagination_test.required_params %}
      {% if param.param_type == "string" %}
      {% if "id" in param.variable_name %}
      'test_id',
      {% elif "query" in param.variable_name %}
      'test_query',
      {% else %}
      'test_{{ param.name }}',
      {% endif %}
      {% elif param.param_type == "boolean" %}
      true,
      {% elif param.param_type == "integer" %}
      1,
      {% else %}
      'test_value',
      {% endif %}
      {% endfor %}
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 2
      };

      // Call method and get first page
      const firstPage = await method.apply({{ tag.property_name }}Client, [...requiredArgs, options]);
      expect(firstPage).toBeDefined();
      expect(firstPage.data).toBeDefined();
      expect(Array.isArray(firstPage.data)).toBe(true);
      expect(firstPage.data.length).toBe(2);

      // If there's a next token, call again with pagination token
      {% if pagination_test.next_token_field %}
      if (firstPage.meta && firstPage.meta['{{ pagination_test.next_token_field|last_part }}']) {
        options.paginationToken = firstPage.meta['{{ pagination_test.next_token_field|last_part }}'];
        const secondPage = await method.apply({{ tag.property_name }}Client, [...requiredArgs, options]);
        expect(secondPage).toBeDefined();
        expect(secondPage.data).toBeDefined();
        expect(Array.isArray(secondPage.data)).toBe(true);
      }
      {% endif %}

      // Should have made multiple requests
      expect((client.httpClient.request as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle pagination parameters correctly for {{ pagination_test.method_name }}', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: async () => ({
        {{ pagination_test.data_field }}: [],
        meta: { result_count: 0 }
      }),
      text: async () => '{}'
    } as Response);

    try {
      const method = ({{ tag.property_name }}Client as any)['{{ pagination_test.method_name }}'];
      
      // Build required parameters as direct arguments (both path and required query params)
      const requiredArgs: any[] = [
      {% for param in pagination_test.required_params %}
      {% if param.param_type == "string" %}
      {% if "id" in param.variable_name %}
      'test_id',
      {% elif "query" in param.variable_name %}
      'test_query',
      {% else %}
      'test_{{ param.name }}',
      {% endif %}
      {% elif param.param_type == "boolean" %}
      true,
      {% elif param.param_type == "integer" %}
      1,
      {% else %}
      'test_value',
      {% endif %}
      {% endfor %}
      ];
      
      // Build options object with optional query parameters (maxResults is always in options)
      const options: any = {
      maxResults: 5
      };

      await method.apply({{ tag.property_name }}Client, [...requiredArgs, options]);

      // Verify maxResults was passed in request (becomes max_results in query string)
      expect(client.httpClient.request).toHaveBeenCalled();
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      // maxResults in options becomes max_results in query string
      expect(url).toMatch(/max_results=5|maxResults=5/);
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  {% endfor %}
});

