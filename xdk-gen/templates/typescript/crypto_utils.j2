/**
 * Environment-agnostic cryptographic utilities for the X API SDK.
 * Provides HMAC-SHA1 implementation that works in both Node.js and browser environments.
 */

/**
 * HMAC-SHA1 implementation that works in both Node.js and browser environments
 */
export class CryptoUtils {
  /**
   * Generate HMAC-SHA1 signature
   * @param key Signing key
   * @param message Message to sign
   * @returns Base64 encoded signature
   */
  static async hmacSha1(key: string, message: string): Promise<string> {
    // Try to use native Node.js crypto first
    if (typeof process !== 'undefined' && process.versions && process.versions.node) {
      try {
        return await this._nodeHmacSha1(key, message);
      } catch (error) {
        // Fall back to Web Crypto API or polyfill
        console.warn('Node.js crypto failed, falling back:', error);
      }
    }

    // Try Web Crypto API (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.subtle) {
      try {
        return await this._webCryptoHmacSha1(key, message);
      } catch (error) {
        // Fall back to polyfill
        console.warn('Web Crypto API failed, falling back:', error);
      }
    }

    // Fall back to polyfill implementation
    return this._polyfillHmacSha1(key, message);
  }

  /**
   * Node.js native HMAC-SHA1 implementation
   */
  private static async _nodeHmacSha1(key: string, message: string): Promise<string> {
    // Dynamic import for Node.js crypto module (ES module compatible)
    const crypto = await import('crypto');
    const hmac = crypto.createHmac('sha1', key);
    hmac.update(message);
    return hmac.digest('base64');
  }

  /**
   * Web Crypto API HMAC-SHA1 implementation
   */
  private static async _webCryptoHmacSha1(key: string, message: string): Promise<string> {
    // Convert string key to ArrayBuffer
    const keyBuffer = this._stringToArrayBuffer(key);
    const messageBuffer = this._stringToArrayBuffer(message);

    // Import the key
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      { name: 'HMAC', hash: 'SHA-1' },
      false,
      ['sign']
    );

    // Sign the message
    const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageBuffer);

    // Convert to base64
    return this._arrayBufferToBase64(signature);
  }

  /**
   * Polyfill HMAC-SHA1 implementation using pure JavaScript
   * This is a fallback that works everywhere but is slower
   */
  private static _polyfillHmacSha1(key: string, message: string): string {
    // For now, throw an error to indicate that proper crypto is needed
    // This will help identify when the fallback is being used
    throw new Error('HMAC-SHA1 polyfill not implemented. Please ensure Node.js crypto or Web Crypto API is available.');
    
    // In a real implementation, you would use a library like crypto-js:
    // import CryptoJS from 'crypto-js';
    // return CryptoJS.HmacSHA1(message, key).toString(CryptoJS.enc.Base64);
  }

  /**
   * Convert string to ArrayBuffer
   */
  private static _stringToArrayBuffer(str: string): ArrayBuffer {
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < str.length; i++) {
      view[i] = str.charCodeAt(i);
    }
    return buffer;
  }

  /**
   * Convert ArrayBuffer to base64 string
   */
  private static _arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  /**
   * Generate a random nonce for OAuth
   * @param length Length of the nonce
   * @returns Random nonce string
   */
  static generateNonce(length: number = 32): string {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      // Use crypto.getRandomValues if available
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    } else {
      // Fallback to Math.random (less secure but functional)
      let result = '';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      return result;
    }
  }

  /**
   * Generate timestamp for OAuth
   * @returns Unix timestamp as string
   */
  static generateTimestamp(): string {
    return Math.floor(Date.now() / 1000).toString();
  }
}

/**
 * Convenience function for HMAC-SHA1
 * @param key Signing key
 * @param message Message to sign
 * @returns Promise that resolves to base64 encoded signature
 */
export async function hmacSha1(key: string, message: string): Promise<string> {
  return CryptoUtils.hmacSha1(key, message);
}

/**
 * Convenience function for generating nonce
 * @param length Length of the nonce
 * @returns Random nonce string
 */
export function generateNonce(length: number = 32): string {
  return CryptoUtils.generateNonce(length);
}

/**
 * Convenience function for generating timestamp
 * @returns Unix timestamp as string
 */
export function generateTimestamp(): string {
  return CryptoUtils.generateTimestamp();
} 