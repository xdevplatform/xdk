/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * This file was automatically generated by the XDK build tool.
 * Any manual changes will be overwritten on the next generation.
 * 
 * Auto-generated contract tests for {{ tag.class_name }} client.
 *
 * This module contains tests that validate the request/response contracts
 * of the {{ tag.class_name }} client against the OpenAPI specification.
 *
 * Generated automatically - do not edit manually.
 */

import { describe, it, expect, beforeAll, jest } from '@jest/globals';
import { {{ tag.class_name }}Client } from '../../src/{{ tag.import_name }}/client.js';
import { Client } from '../../src/client.js';

describe('{{ tag.class_name }}Client Contracts', () => {
  let client: Client;
  let {{ tag.property_name }}Client: {{ tag.class_name }}Client;

  beforeAll(() => {
    client = new Client({ baseUrl: 'https://api.example.com' });
    {{ tag.property_name }}Client = client.{{ tag.property_name }};
  });

  {% for contract_test in test_spec.contract_tests %}
  it('should have correct request structure for {{ contract_test.method_name }}', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request to capture request details (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: {{ contract_test.response_schema.status_code }},
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      {% if tag.import_name == 'stream' or tag.class_name == 'StreamClient' %}
      // For streaming responses, provide a mock ReadableStream body
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      {% endif %}
      json: async () => ({
        {% for field in contract_test.response_schema.expected_fields %}
        {% if field.is_array %}
        {{ field.name }}: [],
        {% elif field.field_type == "string" %}
        {{ field.name }}: 'test_value',
        {% elif field.field_type == "integer" %}
        {{ field.name }}: 42,
        {% elif field.field_type == "boolean" %}
        {{ field.name }}: true,
        {% else %}
        {{ field.name }}: null,
        {% endif %}
        {% endfor %}
      }),
      text: async () => '{}'
    } as Response);

    try {
      // Prepare test parameters
      // In TypeScript, ALL required parameters (path and query) are direct function arguments
      // Only optional parameters go in the options object
      // Build required parameter arguments
      const requiredArgs: any[] = [
      {% for param in contract_test.required_params %}
      {% if param.param_type == "array" %}
      ['test_item'],
      {% elif param.param_type == "string" %}
      'test_{{ param.name }}',
      {% elif param.param_type == "integer" %}
      42,
      {% elif param.param_type == "boolean" %}
      true,
      {% else %}
      'test_value',
      {% endif %}
      {% endfor %}
      ];
      
      // Build options object (empty for required params test, optional params go here)
      const options: any = {};
      
      // Call the method
      const method = ({{ tag.property_name }}Client as any)['{{ contract_test.method_name }}'];
      const result = await method.apply({{ tag.property_name }}Client, [...requiredArgs, options]);
      
      // Verify the request was made
      expect(client.httpClient.request).toHaveBeenCalled();
      
      // Verify request structure
      const callArgs = (client.httpClient.request as jest.Mock).mock.calls[0];
      const url = callArgs[0] as string;
      const requestOptions = callArgs[1] as RequestInit;
      
      // Check URL structure - path parameters are replaced in the URL
      const expectedPath = '{{ contract_test.path }}';
      // Path parameters are replaced with actual values, so check for the base path structure
      const basePath = expectedPath.split('{')[0];
      expect(url).toContain(basePath);
      
      // Verify response structure
      expect(result).toBeDefined();
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should handle required parameters correctly for {{ contract_test.method_name }}', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      {% if tag.import_name == 'stream' or tag.class_name == 'StreamClient' %}
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode('{}'));
          controller.close();
        }
      }),
      {% endif %}
      json: async () => ({}),
      text: async () => '{}'
    } as Response);

    try {
      const method = ({{ tag.property_name }}Client as any)['{{ contract_test.method_name }}'];
      
      {% if contract_test.required_params.length == 0 %}
      // No required parameters, method should be callable without args
      await expect(method.call({{ tag.property_name }}Client)).resolves.toBeDefined();
      {% else %}
      // Method has required parameters - verify it can be called with proper args
      // Build required parameter arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      {% for param in contract_test.required_params %}
      {% if param.param_type == "array" %}
      ['test_item'],
      {% elif param.param_type == "string" %}
      'test_{{ param.name }}',
      {% elif param.param_type == "integer" %}
      42,
      {% elif param.param_type == "boolean" %}
      true,
      {% else %}
      'test_value',
      {% endif %}
      {% endfor %}
      ];
      
      // Build options object (empty for required params, optional params go here)
      const options: any = {};
      
      // Method should be callable with required parameters
      await expect(method.apply({{ tag.property_name }}Client, [...requiredArgs, options])).resolves.toBeDefined();
      {% endif %}
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  it('should validate response structure for {{ contract_test.method_name }}', async () => {
    // Mock validateAuthentication to bypass auth checks (like Python mocks session)
    const originalValidateAuth = client.validateAuthentication;
    client.validateAuthentication = jest.fn();
    
    const mockResponseData = {
      {% for field in contract_test.response_schema.expected_fields %}
      {% if field.is_array %}
      {{ field.name }}: [],
      {% elif field.field_type == "string" %}
      {{ field.name }}: 'test_value',
      {% elif field.field_type == "integer" %}
      {{ field.name }}: 42,
      {% elif field.field_type == "boolean" %}
      {{ field.name }}: true,
      {% else %}
      {{ field.name }}: null,
      {% endif %}
      {% endfor %}
    };

    // Mock httpClient.request (like Python mocks session)
    const originalRequest = client.httpClient.request;
    (client.httpClient.request as any) = jest.fn().mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      {% if tag.import_name == 'stream' or tag.class_name == 'StreamClient' %}
      body: new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode(JSON.stringify(mockResponseData)));
          controller.close();
        }
      }),
      {% endif %}
      json: async () => mockResponseData,
      text: async () => JSON.stringify(mockResponseData)
    } as Response);

    try {
      // Build arguments (all required params are direct args in TypeScript)
      const requiredArgs: any[] = [
      {% for param in contract_test.required_params %}
      {% if param.param_type == "array" %}
      ['test_item'],
      {% elif param.param_type == "string" %}
      'test_{{ param.name }}',
      {% elif param.param_type == "integer" %}
      42,
      {% elif param.param_type == "boolean" %}
      true,
      {% else %}
      'test_value',
      {% endif %}
      {% endfor %}
      ];
      const options: any = {};

      const method = ({{ tag.property_name }}Client as any)['{{ contract_test.method_name }}'];
      const result = await method.apply({{ tag.property_name }}Client, [...requiredArgs, options]);

      // Verify response object has expected structure
      expect(result).toBeDefined();
      {% if tag.import_name == 'stream' or tag.class_name == 'StreamClient' %}
      // For StreamClient methods, check if it's a streaming method (returns EventDrivenStream)
      // Streaming methods return EventDrivenStream, not JSON responses
      // Check if result has stream properties (isConnected) vs JSON properties (data)
      if (result.hasOwnProperty('isConnected')) {
        // It's an EventDrivenStream - verify stream properties
        expect(result).toHaveProperty('isConnected');
      } else {
        // It's a regular JSON response - check for expected fields
        {% for field in contract_test.response_schema.expected_fields %}
        expect(result).toHaveProperty('{{ field.name }}');
        {% endfor %}
      }
      {% else %}
      // Regular JSON response - check for expected fields
      {% for field in contract_test.response_schema.expected_fields %}
      expect(result).toHaveProperty('{{ field.name }}');
      {% endfor %}
      {% endif %}
    } finally {
      client.httpClient.request = originalRequest;
      client.validateAuthentication = originalValidateAuth;
    }
  });

  {% endfor %}
});

