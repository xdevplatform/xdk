{# Macro for generating method parameters #}
{% macro method_parameters(operation) -%}
{%- for param in operation.parameters | selectattr('required') -%}
{%- if param.original_name -%}
{{ param.variable_name }}: {% if param.param_type %}{{ param.param_type | python_type }}{% else %}Any{% endif %}{% if not loop.last or operation.request_body or operation.parameters | rejectattr('required') | list or operation.is_streaming %}, {% endif %}
{%- endif -%}
{%- endfor -%}
{%- if operation.request_body and operation.request_body.required -%}
body: {{ operation.class_name }}Request{% if operation.parameters | rejectattr('required') | list or operation.is_streaming %}, {% endif %}
{%- endif -%}
{%- for param in operation.parameters | rejectattr('required') -%}
{%- if param.original_name -%}
{{ param.variable_name }}: {% if param.param_type %}{{ param.param_type | python_type }}{% else %}Any{% endif %} = None{% if not loop.last or (operation.request_body and not operation.request_body.required) or operation.is_streaming %}, {% endif %}
{%- endif -%}
{%- endfor -%}
{%- if operation.request_body and not operation.request_body.required -%}
body: Optional[{{ operation.class_name }}Request] = None{% if operation.is_streaming %}, {% endif %}
{%- endif -%}
{%- if operation.is_streaming -%}
stream_config: Optional[StreamConfig] = None
{%- endif -%}
{%- endmacro %}

{# Macro to check if operation is paginated #}
{% macro is_paginated(operation) -%}
{%- if operation.parameters and (operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | list | length > 0 or operation.parameters | selectattr('original_name', 'equalto', 'next_token') | list | length > 0) -%}True{%- else -%}False{%- endif -%}
{%- endmacro %}

{# Macro for method return type #}
{% macro return_type(operation) -%}
{% if operation.is_streaming %}Generator[{% if operation.responses and "200" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}, None, None]{% elif operation.parameters and (operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | list | length > 0 or operation.parameters | selectattr('original_name', 'equalto', 'next_token') | list | length > 0) %}Iterator[{% if operation.responses and "200" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}]{% else %}{% if operation.responses and "200" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}{% endif %}
{%- endmacro %}

{# Macro for method docstring #}
{% macro method_docstring(operation) -%}
"""
        {{ operation.summary | default("") }}{% if operation.is_streaming %} (Streaming){% endif %}
        
        {% if operation.description -%}
        {{ operation.description }}
        
        {% endif -%}
        {% if operation.is_streaming -%}
        This is a streaming endpoint that yields data in real-time as it becomes available.
        Each yielded item represents a single data point from the stream.
        
        The connection is automatically managed with exponential backoff retry logic.
        If the stream disconnects, the SDK will automatically reconnect without client intervention.
        
        {% endif -%}
        {% if operation.parameters -%}
        Args:
            {% for param in operation.parameters -%}
            {% if param.original_name -%}
            {{ param.variable_name }}: {% if param.description %}{{ param.description }}{% else %}{{ param.original_name }}{% endif %}
            {% endif -%}
            {% endfor -%}
        {% endif -%}
        {% if operation.request_body -%}
        {% if operation.request_body.content -%}
        {% set content_type = "application/json" -%}
        {% if operation.request_body.content[content_type] -%}
        {% set schema = operation.request_body.content[content_type].schema -%}
            body: {% if schema and schema.description %}{{ schema.description }}{% else %}Request body{% endif %}
        {% else -%}
            body: Request body
        {% endif -%}
        {% else -%}
            body: Request body
        {% endif -%}
        {% endif -%}
        {% if operation.is_streaming -%}
            stream_config: Optional StreamConfig for customizing retry behavior, timeouts, and callbacks.
                Configure max_retries (-1 for infinite), initial_backoff, max_backoff, and lifecycle callbacks
                (on_connect, on_disconnect, on_reconnect, on_error) for monitoring connection state.
        
        Yields:
            {% if operation.responses and "200" in operation.responses or "201" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}: Individual streaming data items
        
        Raises:
            StreamError: If a non-retryable error occurs (auth errors, client errors) or max retries exceeded.
        {% elif operation.parameters and (operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | list | length > 0 or operation.parameters | selectattr('original_name', 'equalto', 'next_token') | list | length > 0) -%}
        
        Yields:
            {% if operation.responses and "200" in operation.responses or "201" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}: One page of results at a time. Automatically handles pagination using next_token.
        
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        {% else -%}
        
        Returns:
            {% if operation.responses and "200" in operation.responses or "201" in operation.responses %}{{ operation.class_name }}Response{% else %}Dict[str, Any]{% endif %}: Response data
        {% endif -%}
        """
{%- endmacro %}

{# Macro for authentication setup #}
{% macro setup_authentication(operation) -%}
{% if operation.security -%}
        {% for security_requirement in operation.security -%}
        {% for scheme_name in security_requirement -%}
        {% if scheme_name == "BearerToken" -%}
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = f"Bearer {self.client.bearer_token}"
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = f"Bearer {self.client.access_token}"
        {% endif -%}
        {% if scheme_name == "OAuth2UserToken" -%}
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = f"Bearer {self.client.access_token}"
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        {% endif -%}
        {% if scheme_name == "UserToken" -%}
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        {% endif -%}
        {% endfor -%}
        {% endfor -%}
        {% endif -%}
{%- endmacro %}

{# Macro to get authentication type flags #}
{% macro get_auth_flags(operation) -%}
{% set ns = namespace(has_bearer_token = false, has_oauth2_token = false, has_oauth1 = false) %}
{% if operation.security %}
{% for security_requirement in operation.security %}
{% for scheme_name in security_requirement %}
{% if scheme_name == "BearerToken" %}
{% set ns.has_bearer_token = true %}
{% endif %}
{% if scheme_name == "OAuth2UserToken" %}
{% set ns.has_oauth2_token = true %}
{% endif %}
{% if scheme_name == "UserToken" %}
{% set ns.has_oauth1 = true %}
{% endif %}
{% endfor %}
{% endfor %}
{% endif %}
{{ ns }}
{%- endmacro %}

{# Macro for building query parameters #}
{% macro build_query_params(operation) -%}
params = {}
        {% for param in operation.parameters -%}
        {% if param.location == "query" -%}
        if {{ param.variable_name }} is not None:
            {% if param.param_type == "array" -%}
            params["{{ param.original_name }}"] = ",".join(str(item) for item in {{ param.variable_name }})
            {% else -%}
            params["{{ param.original_name }}"] = {{ param.variable_name }}
            {% endif %}
        {% endif -%}
        {% endfor -%}
{%- endmacro %}

{# Macro for building URL with path parameters #}
{% macro build_url(operation) -%}
url = self.client.base_url + "{{ operation.path }}"
        {% for param in operation.parameters -%}
        {% if param.location == "path" -%}
        url = url.replace("{{ '{' + param.original_name + '}' }}", str({{ param.variable_name }}))
        {% endif -%}
        {% endfor -%}
{%- endmacro %}

{# Macro for building headers #}
{% macro build_headers(operation) -%}
headers = {% if operation.is_streaming %}{
            "Accept": "application/json",
        }{% else %}{}{% endif %}
        {% for param in operation.parameters -%}
        {% if param.location == "header" -%}
        if {{ param.variable_name }} is not None:
            headers["{{ param.original_name }}"] = {% if operation.is_streaming %}str({{ param.variable_name }}){% else %}{{ param.variable_name }}{% endif %}
        {% endif -%}
        {% endfor -%}
        {% if not operation.is_streaming and operation.request_body and operation.request_body.content -%}
        {% set content_type = "application/json" -%}
        headers["Content-Type"] = "{{ content_type }}"
        {% endif -%}
{%- endmacro %}

{# Macro for preparing request data #}
{% macro prepare_request_data(operation) -%}
        # Prepare request data
        json_data = None
        {% if operation.request_body -%}
        if body is not None:
            json_data = body.model_dump(exclude_none=True) if hasattr(body, 'model_dump') else body
        {% endif -%}
{%- endmacro %}

{# Macro for streaming request logic #}
{% macro streaming_request(operation) -%}
        # Ensure params is defined (build_query_params should set it, but initialize if not)
        try:
            _ = params  # Check if params exists
        except NameError:
            params = {}  # Initialize if not defined
        
        # Use robust streaming with automatic retry and exponential backoff
        yield from stream_with_retry(
            session=self.client.session,
            method="{{ operation.method | lower }}",
            url=url,
            config=stream_config,
            params=params,
            headers=headers,
            {% if operation.request_body %}json_data=json_data,{% endif %}
            {% if operation.responses and "200" in operation.responses %}
            response_model={{ operation.class_name }}Response,
            {% else %}
            response_model=None,
            {% endif %}
        )
{%- endmacro %}

{# Macro for regular request logic #}
{% macro regular_request(operation) -%}
{% set ns = namespace(has_bearer_token = false, has_oauth2_token = false, has_oauth1 = false) %}
{% if operation.security %}
{% for security_requirement in operation.security %}
{% for scheme_name in security_requirement %}
{% if scheme_name == "BearerToken" %}
{% set ns.has_bearer_token = true %}
{% endif %}
{% if scheme_name == "OAuth2UserToken" %}
{% set ns.has_oauth2_token = true %}
{% endif %}
{% if scheme_name == "UserToken" %}
{% set ns.has_oauth1 = true %}
{% endif %}
{% endfor %}
{% endfor %}
{% endif %}
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        
        {% if operation.security %}
        # Count acceptable schemes
        acceptable_schemes = []
        {% if ns.has_bearer_token %}
        acceptable_schemes.append('BearerToken')
        {% endif %}
        {% if ns.has_oauth2_token %}
        acceptable_schemes.append('OAuth2UserToken')
        {% endif %}
        {% if ns.has_oauth1 %}
        acceptable_schemes.append('UserToken')
        {% endif %}
        
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == 'BearerToken' and available_bearer:
                selected_auth = 'bearer_token'
            elif scheme == 'OAuth2UserToken' and available_oauth2:
                selected_auth = 'oauth2_user_context'
            elif scheme == 'UserToken' and available_oauth1:
                selected_auth = 'oauth1'
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "{{ operation.method }}" in ['POST', 'PUT', 'DELETE', 'PATCH']
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if 'UserToken' in acceptable_schemes and available_oauth1:
                    selected_auth = 'oauth1'
                elif 'OAuth2UserToken' in acceptable_schemes and available_oauth2:
                    selected_auth = 'oauth2_user_context'
                elif 'BearerToken' in acceptable_schemes and available_bearer:
                    selected_auth = 'bearer_token'
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if 'BearerToken' in acceptable_schemes and available_bearer:
                    selected_auth = 'bearer_token'
                elif 'OAuth2UserToken' in acceptable_schemes and available_oauth2:
                    selected_auth = 'oauth2_user_context'
                elif 'UserToken' in acceptable_schemes and available_oauth1:
                    selected_auth = 'oauth1'
        {% else %}
        # No security requirements - use default priority
        if available_bearer:
            selected_auth = 'bearer_token'
        elif available_oauth2:
            selected_auth = 'oauth2_user_context'
        elif available_oauth1:
            selected_auth = 'oauth1'
        {% endif %}
        
        # Apply selected authentication
        if selected_auth == 'oauth1':
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ''
            {% if operation.request_body %}
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ''
            {% endif %}
            
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="{{ operation.method }}",
                url=full_url,
                body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == 'bearer_token':
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == 'oauth2_user_context':
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = f"Bearer {self.client.access_token}"
        
        # Make the request
        {% if operation.security %}
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = acceptable_schemes if 'acceptable_schemes' in locals() else []
            if required_schemes:
                available = []
                if available_bearer and 'BearerToken' in required_schemes:
                    available.append('BearerToken')
                if available_oauth2 and 'OAuth2UserToken' in required_schemes:
                    available.append('OAuth2UserToken')
                if available_oauth1 and 'UserToken' in required_schemes:
                    available.append('UserToken')
                if not available:
                    raise ValueError(f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}")
        {% endif %}
        response = self.client.session.{{ operation.method }}(
            url,
            params=params,
            headers=headers,
            {% if operation.request_body %}
            json=json_data,
            {% endif %}
        )

        # Check for errors
        response.raise_for_status()

        # Parse the response data
        response_data = response.json()

        # Convert to Pydantic model if applicable
        {% if operation.responses and "200" in operation.responses or operation.responses and "201" in operation.responses %}
        return {{ operation.class_name }}Response.model_validate(response_data)
        {% else %}
        return response_data
        {% endif %}
{%- endmacro %}

{# Macro for paginated request logic #}
{% macro paginated_request(operation) -%}
{% set ns = namespace(has_bearer_token = false, has_oauth2_token = false, has_oauth1 = false) %}
{% if operation.security %}
{% for security_requirement in operation.security %}
{% for scheme_name in security_requirement %}
{% if scheme_name == "BearerToken" %}
{% set ns.has_bearer_token = true %}
{% endif %}
{% if scheme_name == "OAuth2UserToken" %}
{% set ns.has_oauth2_token = true %}
{% endif %}
{% if scheme_name == "UserToken" %}
{% set ns.has_oauth1 = true %}
{% endif %}
{% endfor %}
{% endfor %}
{% endif %}
        # Determine pagination parameter name
        {% if operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | list | length > 0 %}
        pagination_param_name = "pagination_token"
        {% elif operation.parameters | selectattr('original_name', 'equalto', 'next_token') | list | length > 0 %}
        pagination_param_name = "next_token"
        {% else %}
        pagination_param_name = "pagination_token"  # Default fallback
        {% endif %}
        
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        {% if operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | list | length > 0 %}
        {% set pagination_param = operation.parameters | selectattr('original_name', 'equalto', 'pagination_token') | first %}
        current_pagination_token = {{ pagination_param.variable_name }}
        {% elif operation.parameters | selectattr('original_name', 'equalto', 'next_token') | list | length > 0 %}
        {% set pagination_param = operation.parameters | selectattr('original_name', 'equalto', 'next_token') | first %}
        current_pagination_token = {{ pagination_param.variable_name }}
        {% else %}
        current_pagination_token = None
        {% endif %}
        
        while True:
            # Build query parameters for this page
            page_params = {}
            {% for param in operation.parameters -%}
            {% if param.location == "query" -%}
            {% if param.original_name != "pagination_token" and param.original_name != "next_token" -%}
            if {{ param.variable_name }} is not None:
                {% if param.param_type == "array" -%}
                page_params["{{ param.original_name }}"] = ",".join(str(item) for item in {{ param.variable_name }})
                {% else -%}
                page_params["{{ param.original_name }}"] = {{ param.variable_name }}
                {% endif %}
            {% endif -%}
            {% endif -%}
            {% endfor -%}
            
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
            
            {% if operation.security %}
            # Count acceptable schemes
            page_acceptable_schemes = []
            {% if ns.has_bearer_token %}
            page_acceptable_schemes.append('BearerToken')
            {% endif %}
            {% if ns.has_oauth2_token %}
            page_acceptable_schemes.append('OAuth2UserToken')
            {% endif %}
            {% if ns.has_oauth1 %}
            page_acceptable_schemes.append('UserToken')
            {% endif %}
            
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == 'BearerToken' and page_available_bearer:
                    page_selected_auth = 'bearer_token'
                elif scheme == 'OAuth2UserToken' and page_available_oauth2:
                    page_selected_auth = 'oauth2_user_context'
                elif scheme == 'UserToken' and page_available_oauth1:
                    page_selected_auth = 'oauth1'
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "{{ operation.method }}" in ['POST', 'PUT', 'DELETE', 'PATCH']
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if 'UserToken' in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = 'oauth1'
                    elif 'OAuth2UserToken' in page_acceptable_schemes and page_available_oauth2:
                        page_selected_auth = 'oauth2_user_context'
                    elif 'BearerToken' in page_acceptable_schemes and page_available_bearer:
                        page_selected_auth = 'bearer_token'
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if 'BearerToken' in page_acceptable_schemes and page_available_bearer:
                        page_selected_auth = 'bearer_token'
                    elif 'OAuth2UserToken' in page_acceptable_schemes and page_available_oauth2:
                        page_selected_auth = 'oauth2_user_context'
                    elif 'UserToken' in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = 'oauth1'
            {% else %}
            # No security requirements - use default priority
            if page_available_bearer:
                page_selected_auth = 'bearer_token'
            elif page_available_oauth2:
                page_selected_auth = 'oauth2_user_context'
            elif page_available_oauth1:
                page_selected_auth = 'oauth1'
            {% endif %}
            
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == 'oauth1':
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ''
                {% if operation.request_body %}
                if json_data:
                    # OAuth1 spec: JSON bodies are NOT included in signature
                    # But we still need to pass the body for the request
                    body_string = ''
                {% endif %}
                
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="{{ operation.method }}",
                    url=full_url,
                    body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == 'bearer_token':
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == 'oauth2_user_context':
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            
            # Make the request
            {% if operation.security %}
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = page_acceptable_schemes if 'page_acceptable_schemes' in locals() else []
                if required_schemes:
                    available = []
                    if page_available_bearer and 'BearerToken' in required_schemes:
                        available.append('BearerToken')
                    if page_available_oauth2 and 'OAuth2UserToken' in required_schemes:
                        available.append('OAuth2UserToken')
                    if page_available_oauth1 and 'UserToken' in required_schemes:
                        available.append('UserToken')
                    if not available:
                        raise ValueError(f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}")
            {% endif %}
            response = self.client.session.{{ operation.method }}(
                url,
                params=page_params,
                headers=page_headers,
                {% if operation.request_body %}
                json=json_data,
                {% endif %}
            )

            # Check for errors
            response.raise_for_status()

            # Parse the response data
            response_data = response.json()

            # Convert to Pydantic model if applicable
            {% if operation.responses and "200" in operation.responses or operation.responses and "201" in operation.responses %}
            page_response = {{ operation.class_name }}Response.model_validate(response_data)
            {% else %}
            page_response = response_data
            {% endif %}
            
            # Yield this page
            yield page_response
            
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, 'meta') and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, 'model_dump'):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get('next_token')
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, 'next_token'):
                        next_token = getattr(meta, 'next_token', None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get('next_token')
            except (AttributeError, TypeError):
                pass
            
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get('meta')
                    if meta and isinstance(meta, dict):
                        next_token = meta.get('next_token')
                except (AttributeError, TypeError, KeyError):
                    pass
            
            # If no next_token, we're done
            if not next_token:
                break
            
            # Update token for next iteration
            current_pagination_token = next_token
            
            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits
{%- endmacro %}
