// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.
/**
 * Stream client for the X API.
 *
 * This module provides a client for interacting with the streaming endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions } from '../client.js';
import { EventDrivenStream, StreamEvent } from './event_driven_stream.js';
import {
  GetRepostedByResponse,
  SearchRecentResponse,
  GetRepostsResponse,
  GetByIdResponse,
  DeleteResponse,
  GetAnalyticsResponse,
  SearchAllResponse,
  HideReplyResponse,
  GetLikingUsersResponse,
  GetByIdsResponse,
  CreateResponse,
  GetCountsAllResponse,
  GetInsights28hrResponse,
  GetInsightsHistoricalResponse,
  GetCountsRecentResponse,
  GetQuotedResponse,
} from './models.js';

/**
 * Options for getRepostedBy method
 * 
 * @public
 */
export interface GetRepostedByStreamingOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for searchRecent method
 * 
 * @public
 */
export interface SearchRecentStreamingOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** This order in which to return results. 
     * Also accepts: sort_order or proper camelCase format */
  sortOrder?: string;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getReposts method
 * 
 * @public
 */
export interface GetRepostsStreamingOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getById method
 * 
 * @public
 */
export interface GetByIdStreamingOptions {
  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for delete method
 * 
 * @public
 */
export interface DeleteStreamingOptions {
  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getAnalytics method
 * 
 * @public
 */
export interface GetAnalyticsStreamingOptions {
  /** A comma separated list of Analytics fields to display. 
     * Also accepts: analytics.fields or proper camelCase format */
  analyticsfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for searchAll method
 * 
 * @public
 */
export interface SearchAllStreamingOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** This order in which to return results. 
     * Also accepts: sort_order or proper camelCase format */
  sortOrder?: string;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for hideReply method
 * 
 * @public
 */
export interface HideReplyStreamingOptions {
  /** Request body */
  body?: any;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getLikingUsers method
 * 
 * @public
 */
export interface GetLikingUsersStreamingOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getByIds method
 * 
 * @public
 */
export interface GetByIdsStreamingOptions {
  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for create method
 * 
 * @public
 */
export interface CreateStreamingOptions {
  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getCountsAll method
 * 
 * @public
 */
export interface GetCountsAllStreamingOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The granularity for the search counts results. 
     * Also accepts: granularity or proper camelCase format */
  granularity?: string;

  /** A comma separated list of SearchCount fields to display. 
     * Also accepts: search_count.fields or proper camelCase format */
  searchCountfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getInsights28hr method
 * 
 * @public
 */
export interface GetInsights28hrStreamingOptions {
  /** A comma separated list of Engagement fields to display. 
     * Also accepts: engagement.fields or proper camelCase format */
  engagementfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getInsightsHistorical method
 * 
 * @public
 */
export interface GetInsightsHistoricalStreamingOptions {
  /** A comma separated list of Engagement fields to display. 
     * Also accepts: engagement.fields or proper camelCase format */
  engagementfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getCountsRecent method
 * 
 * @public
 */
export interface GetCountsRecentStreamingOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The granularity for the search counts results. 
     * Also accepts: granularity or proper camelCase format */
  granularity?: string;

  /** A comma separated list of SearchCount fields to display. 
     * Also accepts: search_count.fields or proper camelCase format */
  searchCountfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}
/**
 * Options for getQuoted method
 * 
 * @public
 */
export interface GetQuotedStreamingOptions {
  /** The maximum number of results to be returned. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The set of entities to exclude (e.g. 'replies' or 'retweets'). 
     * Also accepts: exclude or proper camelCase format */
  exclude?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Additional headers */
  headers?: Record<string, string>;
  /** AbortSignal for cancelling the request */
  signal?: AbortSignal;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

export class PostsClient {
  private client: Client;

  constructor(client: Client) {
    this.client = client;
  }

  /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Accepts both formats: tweetFields/tweetfields and tweet.fields/tweet_fields
     */
  private _normalizeOptions<T extends Record<string, any>>(
    options: T,
    paramMappings: Record<string, string>
  ): T {
    if (!options || typeof options !== 'object') {
      return options;
    }

    const normalized: any = { ...options };

    // For each parameter mapping (original -> camelCase)
    for (const [originalName, camelName] of Object.entries(paramMappings)) {
      // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
      if (originalName in normalized && !(camelName in normalized)) {
        normalized[camelName] = normalized[originalName];
        delete normalized[originalName];
      }
      // Also check for camelCase with proper casing (e.g., 'tweetFields')
      const properCamel = this._toCamelCase(originalName);
      if (
        properCamel !== camelName &&
        properCamel in normalized &&
        !(camelName in normalized)
      ) {
        normalized[camelName] = normalized[properCamel];
        delete normalized[properCamel];
      }
    }

    return normalized as T;
  }

  /**
     * Convert a parameter name to proper camelCase
     * e.g., 'tweet.fields' -> 'tweetFields', 'user_fields' -> 'userFields'
     */
  private _toCamelCase(name: string): string {
    return name
      .replace(/[._-]([a-z])/g, (_, letter) => letter.toUpperCase())
      .replace(/^[A-Z]/, letter => letter.toLowerCase());
  }

  /**
     * Get Reposted by
     * Retrieves a list of Users who reposted a specific Post by its ID.
     * 
     * @returns Promise with the API response
     */
  async getRepostedBy(
    id: string,
    options: GetRepostedByStreamingOptions = {}
  ): Promise<GetRepostedByResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getRepostedBy');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'user.fields': 'userfields',

      'tweet.fields': 'tweetfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      maxResults = undefined,

      paginationToken = undefined,

      userfields = [],

      expansions = [],

      tweetfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/retweeted_by';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetRepostedByResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Search recent Posts
     * Retrieves Posts from the last 7 days matching a search query.
     * 
     * @returns Promise with the API response
     */
  async searchRecent(
    query: string,
    options: SearchRecentStreamingOptions = {}
  ): Promise<SearchRecentResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'searchRecent');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      max_results: 'maxResults',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      sort_order: 'sortOrder',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      maxResults = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      sortOrder = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/search/recent';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (sortOrder !== undefined) {
      params.append('sort_order', String(sortOrder));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<SearchRecentResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Reposts
     * Retrieves a list of Posts that repost a specific Post by its ID.
     * 
     * @returns Promise with the API response
     */
  async getReposts(
    id: string,
    options: GetRepostsStreamingOptions = {}
  ): Promise<GetRepostsResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getReposts');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      maxResults = undefined,

      paginationToken = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/retweets';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetRepostsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Post by ID
     * Retrieves details of a specific Post by its ID.
     * 
     * @returns Promise with the API response
     */
  async getById(
    id: string,
    options: GetByIdStreamingOptions = {}
  ): Promise<GetByIdResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getById');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetByIdResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Delete Post
     * Deletes a specific Post by its ID, if owned by the authenticated user.
     * 
     * @returns Promise with the API response
     */
  async delete(
    id: string,
    options: DeleteStreamingOptions = {}
  ): Promise<DeleteResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'delete');

    // Normalize options to handle both camelCase and original API parameter names

    const normalizedOptions = options || {};

    // Destructure options (exclude path parameters, they're already function params)

    const { headers = {}, signal, requestOptions = {} } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<DeleteResponse>(
      'DELETE',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Post analytics
     * Retrieves analytics data for specified Posts within a defined time range.
     * 
     * @returns Promise with the API response
     */
  async getAnalytics(
    ids: Array<any>,
    endTime: string,
    startTime: string,
    granularity: string,
    options: GetAnalyticsStreamingOptions = {}
  ): Promise<GetAnalyticsResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getAnalytics');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'analytics.fields': 'analyticsfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      analyticsfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/analytics';

    // Build query parameters
    const params = new URLSearchParams();

    if (ids !== undefined && ids.length > 0) {
      params.append('ids', ids.join(','));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (analyticsfields !== undefined && analyticsfields.length > 0) {
      params.append('analytics.fields', analyticsfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetAnalyticsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Search all Posts
     * Retrieves Posts from the full archive matching a search query.
     * 
     * @returns Promise with the API response
     */
  async searchAll(
    query: string,
    options: SearchAllStreamingOptions = {}
  ): Promise<SearchAllResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    this.client.validateAuthentication(requiredAuthTypes, 'searchAll');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      max_results: 'maxResults',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      sort_order: 'sortOrder',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      maxResults = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      sortOrder = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/search/all';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (sortOrder !== undefined) {
      params.append('sort_order', String(sortOrder));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<SearchAllResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Hide reply
     * Hides or unhides a reply to a conversation owned by the authenticated user.
     * 
     * @returns Promise with the API response
     */
  async hideReply(
    tweetId: string,
    options: HideReplyStreamingOptions = {}
  ): Promise<HideReplyResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'hideReply');

    // Normalize options to handle both camelCase and original API parameter names

    const normalizedOptions = options || {};

    // Destructure options (exclude path parameters, they're already function params)

    const {
      body,

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{tweet_id}/hidden';

    path = path.replace('{tweet_id}', encodeURIComponent(String(tweetId)));

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      body: JSON.stringify(body),

      ...requestOptions,
    };

    // Make the request
    return this.client.request<HideReplyResponse>(
      'PUT',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Liking Users
     * Retrieves a list of Users who liked a specific Post by its ID.
     * 
     * @returns Promise with the API response
     */
  async getLikingUsers(
    id: string,
    options: GetLikingUsersStreamingOptions = {}
  ): Promise<GetLikingUsersResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getLikingUsers');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'user.fields': 'userfields',

      'tweet.fields': 'tweetfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      maxResults = undefined,

      paginationToken = undefined,

      userfields = [],

      expansions = [],

      tweetfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/liking_users';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetLikingUsersResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Posts by IDs
     * Retrieves details of multiple Posts by their IDs.
     * 
     * @returns Promise with the API response
     */
  async getByIds(
    ids: Array<any>,
    options: GetByIdsStreamingOptions = {}
  ): Promise<GetByIdsResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getByIds');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets';

    // Build query parameters
    const params = new URLSearchParams();

    if (ids !== undefined && ids.length > 0) {
      params.append('ids', ids.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetByIdsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Create or Edit Post
     * Creates a new Post for the authenticated user, or edits an existing Post when edit_options are provided.
     * 
     * @returns Promise with the API response
     */
  async create(
    body: any,
    options: CreateStreamingOptions = {}
  ): Promise<CreateResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'create');

    // Normalize options to handle both camelCase and original API parameter names

    const normalizedOptions = options || {};

    // Destructure options (exclude path parameters, they're already function params)

    const { headers = {}, signal, requestOptions = {} } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets';

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      body: JSON.stringify(body),

      ...requestOptions,
    };

    // Make the request
    return this.client.request<CreateResponse>(
      'POST',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get count of all Posts
     * Retrieves the count of Posts matching a search query from the full archive.
     * 
     * @returns Promise with the API response
     */
  async getCountsAll(
    query: string,
    options: GetCountsAllStreamingOptions = {}
  ): Promise<GetCountsAllResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getCountsAll');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      'search_count.fields': 'searchCountfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      granularity = undefined,

      searchCountfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/counts/all';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (searchCountfields !== undefined && searchCountfields.length > 0) {
      params.append('search_count.fields', searchCountfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetCountsAllResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get 28-hour Post insights
     * Retrieves engagement metrics for specified Posts over the last 28 hours.
     * 
     * @returns Promise with the API response
     */
  async getInsights28hr(
    tweetIds: Array<any>,
    granularity: string,
    requestedMetrics: Array<any>,
    options: GetInsights28hrStreamingOptions = {}
  ): Promise<GetInsights28hrResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getInsights28hr');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'engagement.fields': 'engagementfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      engagementfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/insights/28hr';

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetIds !== undefined && tweetIds.length > 0) {
      params.append('tweet_ids', tweetIds.join(','));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (requestedMetrics !== undefined && requestedMetrics.length > 0) {
      params.append('requested_metrics', requestedMetrics.join(','));
    }

    if (engagementfields !== undefined && engagementfields.length > 0) {
      params.append('engagement.fields', engagementfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetInsights28hrResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get historical Post insights
     * Retrieves historical engagement metrics for specified Posts within a defined time range.
     * 
     * @returns Promise with the API response
     */
  async getInsightsHistorical(
    tweetIds: Array<any>,
    endTime: string,
    startTime: string,
    granularity: string,
    requestedMetrics: Array<any>,
    options: GetInsightsHistoricalStreamingOptions = {}
  ): Promise<GetInsightsHistoricalResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(
      requiredAuthTypes,
      'getInsightsHistorical'
    );

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'engagement.fields': 'engagementfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      engagementfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/insights/historical';

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetIds !== undefined && tweetIds.length > 0) {
      params.append('tweet_ids', tweetIds.join(','));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (requestedMetrics !== undefined && requestedMetrics.length > 0) {
      params.append('requested_metrics', requestedMetrics.join(','));
    }

    if (engagementfields !== undefined && engagementfields.length > 0) {
      params.append('engagement.fields', engagementfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetInsightsHistoricalResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get count of recent Posts
     * Retrieves the count of Posts from the last 7 days matching a search query.
     * 
     * @returns Promise with the API response
     */
  async getCountsRecent(
    query: string,
    options: GetCountsRecentStreamingOptions = {}
  ): Promise<GetCountsRecentResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getCountsRecent');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      'search_count.fields': 'searchCountfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      granularity = undefined,

      searchCountfields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/counts/recent';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (searchCountfields !== undefined && searchCountfields.length > 0) {
      params.append('search_count.fields', searchCountfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetCountsRecentResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
     * Get Quoted Posts
     * Retrieves a list of Posts that quote a specific Post by its ID.
     * 
     * @returns Promise with the API response
     */
  async getQuoted(
    id: string,
    options: GetQuotedStreamingOptions = {}
  ): Promise<GetQuotedResponse> {
    // Validate authentication requirements

    const requiredAuthTypes = [];

    requiredAuthTypes.push('BearerToken');

    requiredAuthTypes.push('OAuth2UserToken');

    requiredAuthTypes.push('UserToken');

    this.client.validateAuthentication(requiredAuthTypes, 'getQuoted');

    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)

    const {
      maxResults = undefined,

      paginationToken = undefined,

      exclude = [],

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      headers = {},
      signal,
      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/quote_tweets';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (exclude !== undefined && exclude.length > 0) {
      params.append('exclude', exclude.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      signal: signal,

      ...requestOptions,
    };

    // Make the request
    return this.client.request<GetQuotedResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }
}
