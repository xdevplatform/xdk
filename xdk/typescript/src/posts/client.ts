// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.

/**
 * posts client for the X API.
 *
 * This module provides a client for interacting with the posts endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions } from '../client.js';
import {
  Paginator,
  PostPaginator,
  UserPaginator,
  EventPaginator,
} from '../paginator.js';
import {
  GetRepostedByResponse,
  SearchRecentResponse,
  GetRepostsResponse,
  GetByIdResponse,
  DeleteResponse,
  GetAnalyticsResponse,
  SearchAllResponse,
  HideReplyRequest,
  HideReplyResponse,
  GetLikingUsersResponse,
  GetByIdsResponse,
  CreateRequest,
  CreateResponse,
  GetCountsAllResponse,
  GetInsights28hrResponse,
  GetInsightsHistoricalResponse,
  GetCountsRecentResponse,
  GetQuotedResponse,
} from './models.js';

/**
 * Options for getRepostedBy method
 * 
 * @public
 */
export interface GetRepostedByOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for searchRecent method
 * 
 * @public
 */
export interface SearchRecentOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** This order in which to return results. 
     * Also accepts: sort_order or proper camelCase format */
  sortOrder?: string;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getReposts method
 * 
 * @public
 */
export interface GetRepostsOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getById method
 * 
 * @public
 */
export interface GetByIdOptions {
  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getAnalytics method
 * 
 * @public
 */
export interface GetAnalyticsOptions {
  /** A comma separated list of Analytics fields to display. 
     * Also accepts: analytics.fields or proper camelCase format */
  analyticsfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for searchAll method
 * 
 * @public
 */
export interface SearchAllOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** This order in which to return results. 
     * Also accepts: sort_order or proper camelCase format */
  sortOrder?: string;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for hideReply method
 * 
 * @public
 */
export interface HideReplyOptions {
  /** Request body */
  body?: HideReplyRequest;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getLikingUsers method
 * 
 * @public
 */
export interface GetLikingUsersOptions {
  /** The maximum number of results. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getByIds method
 * 
 * @public
 */
export interface GetByIdsOptions {
  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getCountsAll method
 * 
 * @public
 */
export interface GetCountsAllOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The granularity for the search counts results. 
     * Also accepts: granularity or proper camelCase format */
  granularity?: string;

  /** A comma separated list of SearchCount fields to display. 
     * Also accepts: search_count.fields or proper camelCase format */
  searchCountfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getInsights28hr method
 * 
 * @public
 */
export interface GetInsights28hrOptions {
  /** A comma separated list of Engagement fields to display. 
     * Also accepts: engagement.fields or proper camelCase format */
  engagementfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getInsightsHistorical method
 * 
 * @public
 */
export interface GetInsightsHistoricalOptions {
  /** A comma separated list of Engagement fields to display. 
     * Also accepts: engagement.fields or proper camelCase format */
  engagementfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getCountsRecent method
 * 
 * @public
 */
export interface GetCountsRecentOptions {
  /** YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Posts will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). 
     * Also accepts: start_time or proper camelCase format */
  startTime?: string;

  /** YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Posts will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). 
     * Also accepts: end_time or proper camelCase format */
  endTime?: string;

  /** Returns results with a Post ID greater than (that is, more recent than) the specified ID. 
     * Also accepts: since_id or proper camelCase format */
  sinceId?: any;

  /** Returns results with a Post ID less than (that is, older than) the specified ID. 
     * Also accepts: until_id or proper camelCase format */
  untilId?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The granularity for the search counts results. 
     * Also accepts: granularity or proper camelCase format */
  granularity?: string;

  /** A comma separated list of SearchCount fields to display. 
     * Also accepts: search_count.fields or proper camelCase format */
  searchCountfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getQuoted method
 * 
 * @public
 */
export interface GetQuotedOptions {
  /** The maximum number of results to be returned. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get a specified 'page' of results. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** The set of entities to exclude (e.g. 'replies' or 'retweets'). 
     * Also accepts: exclude or proper camelCase format */
  exclude?: Array<any>;

  /** A comma separated list of Tweet fields to display. 
     * Also accepts: tweet.fields or proper camelCase format */
  tweetfields?: Array<any>;

  /** A comma separated list of fields to expand. 
     * Also accepts: expansions or proper camelCase format */
  expansions?: Array<any>;

  /** A comma separated list of Media fields to display. 
     * Also accepts: media.fields or proper camelCase format */
  mediafields?: Array<any>;

  /** A comma separated list of Poll fields to display. 
     * Also accepts: poll.fields or proper camelCase format */
  pollfields?: Array<any>;

  /** A comma separated list of User fields to display. 
     * Also accepts: user.fields or proper camelCase format */
  userfields?: Array<any>;

  /** A comma separated list of Place fields to display. 
     * Also accepts: place.fields or proper camelCase format */
  placefields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Client for posts operations
 * 
 * This client provides methods for interacting with the posts endpoints
 * of the X API. It handles authentication, request formatting, and response
 * parsing for all posts related operations.
 * 
 * @category posts
 */
export class PostsClient {
  private client: Client;

  /**
     * Creates a new posts client instance
     * 
     * @param client - The main X API client instance
     */
  constructor(client: Client) {
    this.client = client;
  }

  /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Accepts both formats: tweetFields/tweetfields and tweet.fields/tweet_fields
     */
  private _normalizeOptions<T extends Record<string, any>>(
    options: T,
    paramMappings: Record<string, string>
  ): T {
    if (!options || typeof options !== 'object') {
      return options;
    }

    const normalized: any = { ...options };

    // For each parameter mapping (original -> camelCase)
    for (const [originalName, camelName] of Object.entries(paramMappings)) {
      // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
      if (originalName in normalized && !(camelName in normalized)) {
        normalized[camelName] = normalized[originalName];
        delete normalized[originalName];
      }
      // Also check for camelCase with proper casing (e.g., 'tweetFields')
      const properCamel = this._toCamelCase(originalName);
      if (
        properCamel !== camelName &&
        properCamel in normalized &&
        !(camelName in normalized)
      ) {
        normalized[camelName] = normalized[properCamel];
        delete normalized[properCamel];
      }
    }

    return normalized as T;
  }

  /**
     * Convert a parameter name to proper camelCase
     * e.g., 'tweet.fields' -> 'tweetFields', 'user_fields' -> 'userFields'
     */
  private _toCamelCase(name: string): string {
    return name
      .replace(/[._-]([a-z])/g, (_, letter) => letter.toUpperCase())
      .replace(/^[A-Z]/, letter => letter.toLowerCase());
  }

  /**
   * Get Reposted by
   * Retrieves a list of Users who reposted a specific Post by its ID.


   * @param id A single Post ID.




   * @returns {Promise<GetRepostedByResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getRepostedBy(
    id: string,
    options: GetRepostedByOptions = {}
  ): Promise<GetRepostedByResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'user.fields': 'userfields',

      'tweet.fields': 'tweetfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      maxResults = undefined,

      paginationToken = undefined,

      userfields = [],

      expansions = [],

      tweetfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/retweeted_by';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetRepostedByResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Search recent Posts
   * Retrieves Posts from the last 7 days matching a search query.



   * @param query One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length.



   * @returns {Promise<SearchRecentResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async searchRecent(
    query: string,
    options: SearchRecentOptions = {}
  ): Promise<SearchRecentResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      max_results: 'maxResults',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      sort_order: 'sortOrder',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      maxResults = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      sortOrder = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/search/recent';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (sortOrder !== undefined) {
      params.append('sort_order', String(sortOrder));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<SearchRecentResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Reposts
   * Retrieves a list of Posts that repost a specific Post by its ID.


   * @param id A single Post ID.




   * @returns {Promise<GetRepostsResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getReposts(
    id: string,
    options: GetRepostsOptions = {}
  ): Promise<GetRepostsResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      maxResults = undefined,

      paginationToken = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/retweets';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetRepostsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Post by ID
   * Retrieves details of a specific Post by its ID.


   * @param id A single Post ID.




   * @returns {Promise<GetByIdResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getById(
    id: string,
    options: GetByIdOptions = {}
  ): Promise<GetByIdResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetByIdResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Delete Post
   * Deletes a specific Post by its ID, if owned by the authenticated user.


   * @param id The ID of the Post to be deleted.




   * @returns {Promise<DeleteResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async delete(id: string): Promise<DeleteResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const requestOptions = {};

    // Build the path with path parameters
    let path = '/2/tweets/{id}';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      // No optional parameters, using empty request options
    };

    return this.client.request<DeleteResponse>(
      'DELETE',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Post analytics
   * Retrieves analytics data for specified Posts within a defined time range.



   * @param ids A comma separated list of Post IDs. Up to 100 are allowed in a single request.



   * @param endTime YYYY-MM-DDTHH:mm:ssZ. The UTC timestamp representing the end of the time range.



   * @param startTime YYYY-MM-DDTHH:mm:ssZ. The UTC timestamp representing the start of the time range.



   * @param granularity The granularity for the search counts results.



   * @returns {Promise<GetAnalyticsResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getAnalytics(
    ids: Array<any>,
    endTime: string,
    startTime: string,
    granularity: string,
    options: GetAnalyticsOptions = {}
  ): Promise<GetAnalyticsResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'analytics.fields': 'analyticsfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      analyticsfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/analytics';

    // Build query parameters
    const params = new URLSearchParams();

    if (ids !== undefined && ids.length > 0) {
      params.append('ids', ids.join(','));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (analyticsfields !== undefined && analyticsfields.length > 0) {
      params.append('analytics.fields', analyticsfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetAnalyticsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Search all Posts
   * Retrieves Posts from the full archive matching a search query.



   * @param query One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length.



   * @returns {Promise<SearchAllResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async searchAll(
    query: string,
    options: SearchAllOptions = {}
  ): Promise<SearchAllResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      max_results: 'maxResults',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      sort_order: 'sortOrder',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      maxResults = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      sortOrder = undefined,

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/search/all';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (sortOrder !== undefined) {
      params.append('sort_order', String(sortOrder));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<SearchAllResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Hide reply
   * Hides or unhides a reply to a conversation owned by the authenticated user.


   * @param tweetId The ID of the reply that you want to hide or unhide.




   * @returns {Promise<HideReplyResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async hideReply(
    tweetId: string,
    options: HideReplyOptions = {}
  ): Promise<HideReplyResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const normalizedOptions = options || {};

    // Destructure options (exclude path parameters, they're already function params)
    const {
      body,

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{tweet_id}/hidden';

    path = path.replace('{tweet_id}', encodeURIComponent(String(tweetId)));

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      body: body ? JSON.stringify(body) : undefined,

      ...requestOptions,
    };

    return this.client.request<HideReplyResponse>(
      'PUT',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Liking Users
   * Retrieves a list of Users who liked a specific Post by its ID.


   * @param id A single Post ID.




   * @returns {Promise<GetLikingUsersResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getLikingUsers(
    id: string,
    options: GetLikingUsersOptions = {}
  ): Promise<GetLikingUsersResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'user.fields': 'userfields',

      'tweet.fields': 'tweetfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      maxResults = undefined,

      paginationToken = undefined,

      userfields = [],

      expansions = [],

      tweetfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/liking_users';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetLikingUsersResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Posts by IDs
   * Retrieves details of multiple Posts by their IDs.



   * @param ids A comma separated list of Post IDs. Up to 100 are allowed in a single request.



   * @returns {Promise<GetByIdsResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getByIds(
    ids: Array<any>,
    options: GetByIdsOptions = {}
  ): Promise<GetByIdsResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets';

    // Build query parameters
    const params = new URLSearchParams();

    if (ids !== undefined && ids.length > 0) {
      params.append('ids', ids.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetByIdsResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Create or Edit Post
   * Creates a new Post for the authenticated user, or edits an existing Post when edit_options are provided.



   * @param body Request body

   * @returns {Promise<CreateResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async create(body: CreateRequest): Promise<CreateResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const requestOptions = {};

    // Build the path with path parameters
    let path = '/2/tweets';

    // Build query parameters
    const params = new URLSearchParams();

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      body: JSON.stringify(body || {}),

      // No optional parameters, using empty request options
    };

    return this.client.request<CreateResponse>(
      'POST',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get count of all Posts
   * Retrieves the count of Posts matching a search query from the full archive.



   * @param query One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length.



   * @returns {Promise<GetCountsAllResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getCountsAll(
    query: string,
    options: GetCountsAllOptions = {}
  ): Promise<GetCountsAllResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      'search_count.fields': 'searchCountfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      granularity = undefined,

      searchCountfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/counts/all';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (searchCountfields !== undefined && searchCountfields.length > 0) {
      params.append('search_count.fields', searchCountfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetCountsAllResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get 28-hour Post insights
   * Retrieves engagement metrics for specified Posts over the last 28 hours.



   * @param tweetIds List of PostIds for 28hr metrics.



   * @param granularity granularity of metrics response.



   * @param requestedMetrics request metrics for historical request.



   * @returns {Promise<GetInsights28hrResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getInsights28hr(
    tweetIds: Array<any>,
    granularity: string,
    requestedMetrics: Array<any>,
    options: GetInsights28hrOptions = {}
  ): Promise<GetInsights28hrResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'engagement.fields': 'engagementfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      engagementfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/insights/28hr';

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetIds !== undefined && tweetIds.length > 0) {
      params.append('tweet_ids', tweetIds.join(','));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (requestedMetrics !== undefined && requestedMetrics.length > 0) {
      params.append('requested_metrics', requestedMetrics.join(','));
    }

    if (engagementfields !== undefined && engagementfields.length > 0) {
      params.append('engagement.fields', engagementfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetInsights28hrResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get historical Post insights
   * Retrieves historical engagement metrics for specified Posts within a defined time range.



   * @param tweetIds List of PostIds for historical metrics.



   * @param endTime YYYY-MM-DDTHH:mm:ssZ. The UTC timestamp representing the end of the time range.



   * @param startTime YYYY-MM-DDTHH:mm:ssZ. The UTC timestamp representing the start of the time range.



   * @param granularity granularity of metrics response.



   * @param requestedMetrics request metrics for historical request.



   * @returns {Promise<GetInsightsHistoricalResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getInsightsHistorical(
    tweetIds: Array<any>,
    endTime: string,
    startTime: string,
    granularity: string,
    requestedMetrics: Array<any>,
    options: GetInsightsHistoricalOptions = {}
  ): Promise<GetInsightsHistoricalResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'engagement.fields': 'engagementfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      engagementfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/insights/historical';

    // Build query parameters
    const params = new URLSearchParams();

    if (tweetIds !== undefined && tweetIds.length > 0) {
      params.append('tweet_ids', tweetIds.join(','));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (requestedMetrics !== undefined && requestedMetrics.length > 0) {
      params.append('requested_metrics', requestedMetrics.join(','));
    }

    if (engagementfields !== undefined && engagementfields.length > 0) {
      params.append('engagement.fields', engagementfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetInsightsHistoricalResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get count of recent Posts
   * Retrieves the count of Posts from the last 7 days matching a search query.



   * @param query One query/rule/filter for matching Posts. Refer to https://t.co/rulelength to identify the max query length.



   * @returns {Promise<GetCountsRecentResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getCountsRecent(
    query: string,
    options: GetCountsRecentOptions = {}
  ): Promise<GetCountsRecentResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      start_time: 'startTime',

      end_time: 'endTime',

      since_id: 'sinceId',

      until_id: 'untilId',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      'search_count.fields': 'searchCountfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      startTime = undefined,

      endTime = undefined,

      sinceId = undefined,

      untilId = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      granularity = undefined,

      searchCountfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/counts/recent';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (startTime !== undefined) {
      params.append('start_time', String(startTime));
    }

    if (endTime !== undefined) {
      params.append('end_time', String(endTime));
    }

    if (sinceId !== undefined) {
      params.append('since_id', String(sinceId));
    }

    if (untilId !== undefined) {
      params.append('until_id', String(untilId));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (granularity !== undefined) {
      params.append('granularity', String(granularity));
    }

    if (searchCountfields !== undefined && searchCountfields.length > 0) {
      params.append('search_count.fields', searchCountfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetCountsRecentResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Quoted Posts
   * Retrieves a list of Posts that quote a specific Post by its ID.


   * @param id A single Post ID.




   * @returns {Promise<GetQuotedResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getQuoted(
    id: string,
    options: GetQuotedOptions = {}
  ): Promise<GetQuotedResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      pagination_token: 'paginationToken',

      'tweet.fields': 'tweetfields',

      'media.fields': 'mediafields',

      'poll.fields': 'pollfields',

      'user.fields': 'userfields',

      'place.fields': 'placefields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      maxResults = undefined,

      paginationToken = undefined,

      exclude = [],

      tweetfields = [],

      expansions = [],

      mediafields = [],

      pollfields = [],

      userfields = [],

      placefields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/tweets/{id}/quote_tweets';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (exclude !== undefined && exclude.length > 0) {
      params.append('exclude', exclude.join(','));
    }

    if (tweetfields !== undefined && tweetfields.length > 0) {
      params.append('tweet.fields', tweetfields.join(','));
    }

    if (expansions !== undefined && expansions.length > 0) {
      params.append('expansions', expansions.join(','));
    }

    if (mediafields !== undefined && mediafields.length > 0) {
      params.append('media.fields', mediafields.join(','));
    }

    if (pollfields !== undefined && pollfields.length > 0) {
      params.append('poll.fields', pollfields.join(','));
    }

    if (userfields !== undefined && userfields.length > 0) {
      params.append('user.fields', userfields.join(','));
    }

    if (placefields !== undefined && placefields.length > 0) {
      params.append('place.fields', placefields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetQuotedResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }
}
