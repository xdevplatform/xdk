// AUTO-GENERATED FILE - DO NOT EDIT
// This file was automatically generated by the XDK build tool.
// Any manual changes will be overwritten on the next generation.

/**
 * communities client for the X API.
 *
 * This module provides a client for interacting with the communities endpoints of the X API.
 */

import { Client, ApiResponse, RequestOptions } from '../client.js';
import {
  Paginator,
  PostPaginator,
  UserPaginator,
  EventPaginator,
} from '../paginator.js';
import { SearchResponse, GetByIdResponse } from './models.js';

/**
 * Options for search method
 * 
 * @public
 */
export interface SearchOptions {
  /** The maximum number of search results to be returned by a request. 
     * Also accepts: max_results or proper camelCase format */
  maxResults?: number;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: next_token or proper camelCase format */
  nextToken?: any;

  /** This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. 
     * Also accepts: pagination_token or proper camelCase format */
  paginationToken?: any;

  /** A comma separated list of Community fields to display. 
     * Also accepts: community.fields or proper camelCase format */
  communityfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Options for getById method
 * 
 * @public
 */
export interface GetByIdOptions {
  /** A comma separated list of Community fields to display. 
     * Also accepts: community.fields or proper camelCase format */
  communityfields?: Array<any>;

  /** Additional request options */
  requestOptions?: RequestOptions;
  /** Allow original API parameter names (e.g., 'tweet.fields', 'user.fields') and proper camelCase (e.g., 'tweetFields', 'userFields') */
  [key: string]: any;
}

/**
 * Client for communities operations
 * 
 * This client provides methods for interacting with the communities endpoints
 * of the X API. It handles authentication, request formatting, and response
 * parsing for all communities related operations.
 * 
 * @category communities
 */
export class CommunitiesClient {
  private client: Client;

  /**
     * Creates a new communities client instance
     * 
     * @param client - The main X API client instance
     */
  constructor(client: Client) {
    this.client = client;
  }

  /**
     * Normalize options object to handle both camelCase and original API parameter names
     * Accepts both formats: tweetFields/tweetfields and tweet.fields/tweet_fields
     */
  private _normalizeOptions<T extends Record<string, any>>(
    options: T,
    paramMappings: Record<string, string>
  ): T {
    if (!options || typeof options !== 'object') {
      return options;
    }

    const normalized: any = { ...options };

    // For each parameter mapping (original -> camelCase)
    for (const [originalName, camelName] of Object.entries(paramMappings)) {
      // Check if original format is used (e.g., 'tweet.fields', 'tweet_fields')
      if (originalName in normalized && !(camelName in normalized)) {
        normalized[camelName] = normalized[originalName];
        delete normalized[originalName];
      }
      // Also check for camelCase with proper casing (e.g., 'tweetFields')
      const properCamel = this._toCamelCase(originalName);
      if (
        properCamel !== camelName &&
        properCamel in normalized &&
        !(camelName in normalized)
      ) {
        normalized[camelName] = normalized[properCamel];
        delete normalized[properCamel];
      }
    }

    return normalized as T;
  }

  /**
     * Convert a parameter name to proper camelCase
     * e.g., 'tweet.fields' -> 'tweetFields', 'user_fields' -> 'userFields'
     */
  private _toCamelCase(name: string): string {
    return name
      .replace(/[._-]([a-z])/g, (_, letter) => letter.toUpperCase())
      .replace(/^[A-Z]/, letter => letter.toLowerCase());
  }

  /**
   * Search Communities
   * Retrieves a list of Communities matching the specified search query.



   * @param query Query to search communities.



   * @returns {Promise<SearchResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async search(
    query: string,
    options: SearchOptions = {}
  ): Promise<SearchResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      max_results: 'maxResults',

      next_token: 'nextToken',

      pagination_token: 'paginationToken',

      'community.fields': 'communityfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      maxResults = undefined,

      nextToken = undefined,

      paginationToken = undefined,

      communityfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/communities/search';

    // Build query parameters
    const params = new URLSearchParams();

    if (query !== undefined) {
      params.append('query', String(query));
    }

    if (maxResults !== undefined) {
      params.append('max_results', String(maxResults));
    }

    if (nextToken !== undefined) {
      params.append('next_token', String(nextToken));
    }

    if (paginationToken !== undefined) {
      params.append('pagination_token', String(paginationToken));
    }

    if (communityfields !== undefined && communityfields.length > 0) {
      params.append('community.fields', communityfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<SearchResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }

  /**
   * Get Community by ID
   * Retrieves details of a specific Community by its ID.


   * @param id The ID of the Community.




   * @returns {Promise<GetByIdResponse>} Promise resolving to the API response
   */
  // Overload 1: Default behavior (unwrapped response)
  async getById(
    id: string,
    options: GetByIdOptions = {}
  ): Promise<GetByIdResponse> {
    // Normalize options to handle both camelCase and original API parameter names

    const paramMappings: Record<string, string> = {
      'community.fields': 'communityfields',
    };
    const normalizedOptions = this._normalizeOptions(
      options || {},
      paramMappings
    );

    // Destructure options (exclude path parameters, they're already function params)
    const {
      communityfields = [],

      requestOptions: requestOptions = {},
    } = normalizedOptions;

    // Build the path with path parameters
    let path = '/2/communities/{id}';

    path = path.replace('{id}', encodeURIComponent(String(id)));

    // Build query parameters
    const params = new URLSearchParams();

    if (communityfields !== undefined && communityfields.length > 0) {
      params.append('community.fields', communityfields.join(','));
    }

    // Prepare request options
    const finalRequestOptions: RequestOptions = {
      ...requestOptions,
    };

    return this.client.request<GetByIdResponse>(
      'GET',
      path + (params.toString() ? `?${params.toString()}` : ''),
      finalRequestOptions
    );
  }
}
